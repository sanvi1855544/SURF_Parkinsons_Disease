
<!DOCTYPE html>
<html>
    <head>
        <div class="container">
            <img src="/static/caltech_logo.png" width="90" height="40" alt="giffin" class="right-align"/>
        </div>
        <title> Stablehand2: Parkinson's disease </title>
        <link rel="stylesheet" type="text/css" href="/static/styles.css">
        <style>
            body {
                margin: 0;
                overflow: hidden;
                display: flex;
                justify-content: center;
                align-items: center;
                height: 100vh;
                background-color: #f0f0f0;
            }

            .container {
                text-align: left;
                margin-left: 150px;
            }

            label {
                display: block;
                margin-bottom: 5px;
            }

            input[type="number"] {
                width: 60px;
                padding: 5px;
                border-radius: 5px;
                border: 1px solid #ccc;
                margin-bottom: 10px;
            }

            input[type="color"] {
                padding: 5px;
                margin-bottom: 10px;
            }

            button {
                padding: 10px 20px;
                background-color: #4caf50;
                color: #fff;
                border: none;
                border-radius: 5px;
                cursor: pointer;
            }
        </style>
    </head>
        <p><div class = "nav">
            <p><a href="{{ url_for('index') }}">Home</a></p>
            <p><a href="{{ url_for('survey') }}">Survey</a></p>
            <p><a href="{{ url_for('instructions') }}">Instructions</a></p>
            <p><a href="{{ url_for('contact') }}">Contact</a></p>
            <p><a href="{{ url_for('register') }}">Register</a></p>
            <p><a href="{{ url_for('login') }}">Login</a></p>
        </div></p>
    <body>
        <div class="container">
            <label for="numLayers">Layers:</label>
            <input type="number" id="numLayers" min="1" max="100" value="8" />

            <label for="length">Length:</label>
            <input type="number" id="length" min="10" max="200" value="100" />

            <label for="height">Height:</label>
            <input type="number" id="height" min="10" max="200" value="100" />

            <label for="sineRows">Sine Rows:</label>
            <input type="number" id="sineRows" min="1" max="8" value="4" />

            <label for="sineAmplitude">Sine Amplitude:</label>
            <input type="number" id="sineAmplitude" min="10" max="100" value="50" />

            <label for="direction">Direction:</label>
            <select id="direction">
                <option value="right">Right</option>
                <option value="left">Left</option>
                <option value="up">Up</option>
                <option value="down">Down</option>
            </select>


            <label for="animationSpeed">Animation Speed:</label>
            <input
                type="number"
                id="animationSpeed"
                min="1"
                max="10"
                value="2"
            />

            <label for="color">Color:</label>
            <input type="color" id="color" value="#000000" />

            <label for="backgroundColor">Background Color:</label>
            <input type="color" id="backgroundColor" value="#f0f0f0" />

            <label for="patternType">Pattern Type:</label>
            <select id="patternType">
                <option value="checkerboard">Checkerboard</option>
                <option value="sine">Sine</option>
                <option value="chevron">Chevron</option>
            </select>


            <label for="patternWidth">Pattern Width:</label>
            <input
                type="number"
                id="patternWidth"
                min="0"
                max="3456"
                value="1500"
            />

            <button id="updateBtn">Enter</button>
        </div>

        <canvas id="canvas"></canvas>

        <script>
            let numLayers = 8;
            let length = 100;
            let height = 100;
            let sineRows = 4
            let sineAmplitude = 50;
            let animationSpeed = 2;
            let color = "#000000";
            let backgroundColor = "#f0f0f0";
            let patternType = "checkerboard";
            let patternAngle = 0;
            let patternWidth = 1500;

            // Create canvas and context
            const canvas = document.getElementById("canvas");
            const ctx = canvas.getContext("2d");

            // Sine wave:
            const sineWave = {
                freq: 0.027,
                speed: 0.2,
                phi: 0,
            }

            // Chevron
            const cRows = 5;
            const nRows = 10;
            const chevron = {
                width: 70,
                height: 150,
                speed: 0.2
            }


            // Checkerboard size and properties
            let numUnits = Math.floor((patternWidth + 600) / length); // Adjusted width with white space
            let canvasHeight = height * numLayers;

            // Update canvas size
            function updateCanvasSize() {
                canvas.width = window.innerWidth;
                canvasHeight = height * numLayers;
                canvas.height = canvasHeight;
                numUnits = Math.floor((patternWidth + 600) / length); // Adjusted width with white space
            }

            // Function to draw a single square on the canvas
            function drawSquare(x, y, color) {
                ctx.fillStyle = color;
                ctx.fillRect(x, y, length, height);
            }

            // Function to draw the checkerboard pattern
            function drawCheckerboardRight() {
                for (let j = 0; j < numLayers; j++) {
                    for (let i = 0; i < numUnits; i++) {
                        const x = (i * length + offset);
                        const y = j * height;

                        if ((i + j) % 2 === 0) {
                            drawSquare(x, y, color);
                        } else {
                            drawSquare(x, y, backgroundColor);
                        }
                    }
                }

                // Draw rectangles to cover the sides based on pattern width
                ctx.fillStyle = backgroundColor;
                ctx.fillRect(
                    0,
                    0,
                    (window.innerWidth - patternWidth) / 2,
                    canvasHeight
                );
                ctx.fillRect(
                    window.innerWidth - (window.innerWidth - patternWidth) / 2,
                    0,
                    (window.innerWidth - patternWidth) / 2,
                    canvasHeight
                );
            }



            function drawCheckerboardLeft() {
                const patternWidth = (numUnits + 100) * length;
                offset = (offset - animationSpeed) % (patternWidth);
                for (let j = 0; j < numLayers; j++) {
                    for (let i = 1; i < numUnits + 100; i++) {
                        const x = (i * length + offset) % patternWidth;
                        if ( x < 0 ){
                            offset += patternWidth;
                        }
                        const y = j * height;

                        if ((i + j) % 2 === 0) {
                            drawSquare(x, y, color);
                        } else {
                            drawSquare(x, y, backgroundColor);
                        }
                    }
                }

                // Draw rectangles to cover the sides based on pattern width
                ctx.fillStyle = backgroundColor;
                ctx.fillRect(
                    0,
                    0,
                    (window.innerWidth - patternWidth) / 2,
                    canvasHeight
                );
                ctx.fillRect(
                    window.innerWidth - (window.innerWidth - patternWidth) / 2,
                    0,
                    (window.innerWidth - patternWidth) / 2,
                    canvasHeight
                );
            }


            function drawCheckerboardUp(){
                const patternWidth = (numUnits) * height;
                offset = (offset - (Date.now() * animationSpeed * 0.1)) % (patternWidth);

                if (offset < 0){
                    offset += patternWidth
                }
                
                for (let j = 0; j < numUnits; j++) {
                    for (let i = 0; i < numUnits; i++) {
                        const x = i * length;
                        const y = ((j * height + offset) % patternWidth) % patternWidth;

                        if ((i + j) % 2 === 0) {
                            drawSquare(x, y, color);
                        } else {
                            drawSquare(x, y, backgroundColor);
                        }
                    }
                }

                // Draw rectangles to cover the sides based on pattern width
                ctx.fillStyle = backgroundColor;
                ctx.fillRect(
                    0,
                    0,
                    (window.innerWidth - patternWidth) / 2,
                    canvasHeight
                );
                ctx.fillRect(
                    window.innerWidth - (window.innerWidth - patternWidth) / 2,
                    0,
                    (window.innerWidth - patternWidth) / 2,
                    canvasHeight
                );
                
            }


            function drawCheckerboardDown() {
                const patternWidth = (numUnits) * height;
                offset = (offset + (Date.now() * animationSpeed * 0.1)) % (patternWidth);

                if (offset < 0){
                    offset += patternWidth
                }
                
                for (let j = 0; j < numUnits; j++) {
                    for (let i = 0; i < numUnits; i++) {
                        const x = i * length;
                        const y = ((j * height + offset) % patternWidth) % patternWidth;

                        if ((i + j) % 2 === 0) {
                            drawSquare(x, y, color);
                        } else {
                            drawSquare(x, y, backgroundColor);
                        }
                    }
                }

                // Draw rectangles to cover the sides based on pattern width
                ctx.fillStyle = backgroundColor;
                ctx.fillRect(
                    0,
                    0,
                    (window.innerWidth - patternWidth) / 2,
                    canvasHeight
                );
                ctx.fillRect(
                    window.innerWidth - (window.innerWidth - patternWidth) / 2,
                    0,
                    (window.innerWidth - patternWidth) / 2,
                    canvasHeight
                );
                
            }


            // Function to draw the sine pattern horizontally
            function drawSineH(row) {
                const yCenter = ((canvas.height/sineRows) * row) + 100 ;

                ctx.beginPath();
                ctx.moveTo(0, yCenter);


                ctx.lineWidth = 40;

                for (let x=0; x < canvas.width; x++){
                    const y = sineAmplitude * Math.sin(sineWave.freq * x + sineWave.phi);
                    ctx.lineTo(x, yCenter - y);
                }

                
                ctx.strokeStyle = color;
                ctx.stroke();


            }

            // Function to draw the sine pattern vertically
            function drawSineV(row) {
                const xCenter = ((canvas.width/sineRows) * row) + 100 ;

                ctx.beginPath();
                ctx.moveTo(xCenter, 0);


                ctx.lineWidth = 40;

                for (let y=0; y < canvas.height; y++){
                    const x = sineAmplitude * Math.sin(sineWave.freq * y + sineWave.phi);
                    ctx.lineTo(xCenter - x, y);
                }

                
                ctx.strokeStyle = color;
                ctx.stroke();
            }

            function drawRightChevron(row, speed) {
                const yCenter = ((canvas.height/cRows) * row) + 100;
                const nChevrons = 22;
                const spacing = 70;
                const time = speed * Date.now();

                for (let i = 0; i < nChevrons; i++){
                    const xCenter = ((canvas.height/2) + (time / 10) + i * (canvas.width + spacing)) % canvas.width; 
                    ctx.beginPath();
                    ctx.moveTo(xCenter, yCenter);
                    ctx.lineWidth = 5;
                    ctx.lineTo(xCenter + chevron.width/2, yCenter + chevron.height/2);
                    ctx.lineTo(xCenter, yCenter + (chevron.height));
                    ctx.lineTo(xCenter - chevron.width, yCenter + chevron.height);
                    ctx.lineTo(xCenter - 1/2*chevron.width, yCenter + chevron.height/2);
                    ctx.lineTo(xCenter - chevron.width, yCenter)
                    ctx.closePath();

                    if (i % 2 === 0){
                        ctx.fillStyle = backgroundColor;
                        ctx.fill();
                    }else{
                        ctx.fillStyle = color;
                        ctx.fill();
                    }
                }
            }

            function drawLeftChevron(row, speed) {
                const yCenter = ((canvas.height/cRows) * row) + 100;
                const nChevrons = 22;
                const spacing = 70;
                const time = (speed) * Date.now();
                // const tWidth = nChevrons * (chevron.width + spacing);
                // const offset = (canvas.width + spacing) - ((time) % tWidth);
                for (let i = 0; i < nChevrons; i++){
                    const xCenter = canvas.width - ((canvas.height / 2) + (time / 10) + i * (canvas.width + spacing)) % canvas.width;
                    ctx.beginPath();
                    ctx.moveTo(xCenter, yCenter);
                    ctx.lineWidth = 5;
                    ctx.lineTo(xCenter - chevron.width, yCenter)
                    ctx.lineTo(xCenter - 3/2*chevron.width, yCenter + chevron.height/2);
                    ctx.lineTo(xCenter - chevron.width, yCenter + chevron.height);
                    ctx.lineTo(xCenter, yCenter + (chevron.height));
                    ctx.lineTo(xCenter - 1/2*chevron.width, yCenter + chevron.height/2);
                    ctx.closePath();
                    if (i % 2 === 0){
                        ctx.fillStyle = backgroundColor;
                        ctx.fill();
                    }else{
                        ctx.fillStyle = color;
                        ctx.fill();
                    }
                }
            }

            function drawChevronUp(row, speed) {
                const xCenter = ((canvas.width/nRows) * row);
                const nChevrons = 14;
                const spacing = 100;
                const time = (speed) * Date.now();
                for (let i = 0; i < nChevrons; i++){
                    const yCenter = canvas.height - ((canvas.width / 2) + (time / 10) + i * (canvas.height + spacing)) % canvas.height;
                    ctx.beginPath();
                    ctx.moveTo(xCenter, yCenter);
                    ctx.lineWidth = 5;
                    ctx.lineTo(xCenter - chevron.height/2, yCenter - chevron.width/2);
                    ctx.lineTo(xCenter - chevron.height, yCenter);
                    ctx.lineTo(xCenter - chevron.height, yCenter + chevron.width);
                    ctx.lineTo(xCenter - chevron.height/2, yCenter + chevron.width/2);
                    ctx.lineTo(xCenter, yCenter + chevron.width);
                    ctx.closePath();

                    ctx.fillStyle = color;
                    ctx.fill();

                }
            }

            function drawChevronDown(row, speed) {
                const xCenter = ((canvas.width/nRows) * row);
                const nChevrons = 14;
                const spacing = 100;
                const time = (speed) * Date.now();
                for (let i = 0; i < nChevrons; i++){
                    const yCenter = ((canvas.width / 2) + (time / 10) + i * (canvas.height + spacing)) % canvas.height;
                    ctx.beginPath();
                    ctx.moveTo(xCenter, yCenter);
                    ctx.lineWidth = 5;
                    ctx.lineTo(xCenter - chevron.height/2, yCenter + chevron.width/2)
                    ctx.lineTo(xCenter - chevron.height, yCenter);
                    ctx.lineTo(xCenter - chevron.height, yCenter + chevron.width);
                    ctx.lineTo(xCenter - chevron.height/2, yCenter + 3*chevron.width/2)
                    ctx.lineTo(xCenter, yCenter + chevron.width);
                    ctx.closePath();

                    ctx.fillStyle = color;
                    ctx.fill();

                }
            }



            // Update the pattern based on the selected pattern type
            function updatePattern() {
                if (direction === "right"){
                    if (patternType === "checkerboard") {
                        drawCheckerboardRight();
                    } else if (patternType === "sine") {
                        for (let i = 0; i < sineRows; i++){
                            drawSineH(i);
                        }
                        sineWave.phi -= sineWave.speed * animationSpeed;
                    } else if (patternType === "chevron") {
                        for (let i = 0; i < cRows; i++){
                            drawRightChevron(i, animationSpeed);
                        }
                    }
                } else if (direction === "left"){
                    if (patternType === "checkerboard") { 
                        drawCheckerboardLeft();
                    } else if (patternType === "sine") {
                        for (let i = 0; i < sineRows; i++){
                            drawSineH(i);
                        }
                        sineWave.phi += sineWave.speed * animationSpeed;
                    } else if (patternType === "chevron") {
                        for (let i = 0; i < cRows; i++){
                            drawLeftChevron(i, animationSpeed);
                        }
                    }
                } else if (direction === "up"){
                    if (patternType === "checkerboard"){
                        drawCheckerboardUp();
                    } else if (patternType === "sine") {
                        for (let i = 0; i < sineRows; i++){
                            drawSineV(i);
                        }
                        sineWave.phi += sineWave.speed * animationSpeed;
                    } else if (patternType === "chevron"){
                        for (let i = 0; i < nRows; i++){
                            drawChevronUp(i, animationSpeed);
                        }
                    }
                } else if (direction === "down"){
                    if (patternType === "checkerboard"){
                        drawCheckerboardDown()
                    } else if (patternType === "sine") {
                        for (let i = 0; i < sineRows; i++){
                            drawSineV(i);
                        }
                        sineWave.phi -= sineWave.speed * animationSpeed;
                    } else if (patternType === "chevron"){
                        for (let i = 0; i < nRows; i++){
                            drawChevronDown(i, animationSpeed);
                        }
                    }
                }
                
            }


            // Checkerboard animation variables
            let offset = 0;
            let animationId;
            let lastFrameTime = 0;
            const frameRate = 60;
            const frameDuration = 1000 / frameRate;

            // Animation loop
            function animate(timestamp) {
                const elapsed = timestamp - lastFrameTime;

                if (elapsed > frameDuration) {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    updatePattern();

                    if (direction == 'left' && patternType == "checkerboard"){
                        offset -= animationSpeed; 
                    } else if (direction == 'down' && patternType == "chevron") {
                        offset -= animationSpeed;
                    } else{
                        offset += animationSpeed; // Adjust the speed of the animation by changing this value
                    }
                    
                    // Reset the offset when the pattern goes off the screen
                    if (offset >= 2 * length) {
                        offset = 0;
                    }

                    lastFrameTime = timestamp;
                }

                animationId = requestAnimationFrame(animate);
            }

            // Start the animation
            function startAnimation() {
                animationId = requestAnimationFrame(animate);
            }

            // Stop the animation
            function stopAnimation() {
                cancelAnimationFrame(animationId);
            }

            // Function to update variables and restart the animation
            function updateVariables() {
                numLayers = parseInt(
                    document.getElementById("numLayers").value
                );
                length = parseInt(document.getElementById("length").value);
                height = parseInt(document.getElementById("height").value);
                sineRows = parseInt(document.getElementById("sineRows").value);
                sineAmplitude = parseInt(document.getElementById("sineAmplitude").value);
                animationSpeed = parseInt(
                    document.getElementById("animationSpeed").value
                );
                color = document.getElementById("color").value;
                backgroundColor =
                    document.getElementById("backgroundColor").value;
                patternType = document.getElementById("patternType").value;
                direction = document.getElementById("direction").value;
                patternAngle = parseInt(
                    document.getElementById("patternAngle").value
                );
                patternWidth = parseInt(
                    document.getElementById("patternWidth").value
                );

                updateCanvasSize();
                stopAnimation();
                startAnimation();
            }

            // Event listener for the Enter button
            document
                .getElementById("updateBtn")
                .addEventListener("click", updateVariables);

            // Resize canvas and start animation when the window is resized
            window.addEventListener("resize", function () {
                updateCanvasSize();
                stopAnimation();
                startAnimation();
            });

            // Initial setup
            updateCanvasSize();
            startAnimation();
        </script>
    </body>
</html>